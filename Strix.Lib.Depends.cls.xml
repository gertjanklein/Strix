<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Class name="Strix.Lib.Depends">
<IncludeCode>%occErrors</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>65091,28435.781976</TimeCreated>

<Property name="Checked">
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="Dependencies">
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<UDLText name="T">
<Content><![CDATA[
// -----

]]></Content>
</UDLText>

<Property name="Matchers">
<Description>
Cached regex objects (performance)</Description>
<Type>%Regex.Matcher</Type>
<Collection>array</Collection>
</Property>

<UDLText name="T">
<Content><![CDATA[
// =====

]]></Content>
</UDLText>

<Method name="CheckPackage">
<Description>
Check all dependencies of one or more packages.</Description>
<FormalSpec>Packages:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	For i = 1:1:$Length(Packages, ",") {
		Set Package = $Piece(Packages, ",", i)
		
		Kill Items
		Set sc = $System.OBJ.GetPackageList(.Items, Package)
		If 'sc Return ..BuildStatus("Error determining package list for '{}':", sc, Package)
		
		Set Item = ""
		For  {
			Set Item = $Order(Items(Item))
			If Item= "" Quit
			
			Do ..AddItem(Item_".cls", Item)
			Set sc = ..CheckItem(Item_".cls")
			If 'sc Return ..BuildStatus("Error checking '{}':", sc, Item)
		}
	}
	
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="CheckItem">
<Description>
Checks dependencies for a single item.</Description>
<FormalSpec>Item:%String,Recursive:%Boolean=1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set Type = $ZConvert($Piece(Item, ".", *), "l")
	If Type = "cls" {
		Set sc = ..CheckClass($Piece(Item, ".", 1, *-1))
		If 'sc Quit sc
		
	} Else {
		Quit ..BuildStatus("Error: unsupported type '{}'.",, Type)
	}
	
	Set Dep = ""
	For  {
		Set Dep = $Order(..Dependencies(Dep), 1, ReferencedBy)
		If Dep = "" Quit
		If $Data(..Checked(Dep)) Continue
		
		Set Type = $Piece(Dep, ".", *)
		If Type = "cls" {
			Set Cls = $Piece(Dep, ".", 1, *-1)
			If '##class(%Dictionary.ClassDefinition).%ExistsId(Cls) {
				Write "Warning: dependency "_Cls_" of "_ReferencedBy_" does not exist.",!
				Set ..Checked(Dep) = ""
				Continue
			}
			
			If Recursive {
				Set sc = ..CheckItem(Dep)
				If 'sc Return ..BuildStatus("Error checking dependency {}:", sc, Dep)
			}
		}
	}
	
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="CheckClass">
<Description>
Checks a single class for its dependencies</Description>
<FormalSpec>ClassName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set ..Checked(ClassName_".cls") = ""
	
	; Start with what this returns:
	Set sc = $System.OBJ.GetDependencies(ClassName, .Items, "ckrby")
	If 'sc Quit ..BuildStatus("Error from system for class {}:", sc, ClassName)
	
	Set Item = ""
	For  {
		Set Item = $Order(Items(Item))
		If Item = "" Quit
		Set Name = Item_".cls"
		If '$Data(..Checked(Name)) Do ..AddItem(Name, ClassName)
	}
	
	
	Set Def = ##class(%Dictionary.ClassDefinition).%OpenId(ClassName, , .sc)
	If 'sc Quit ..BuildStatus("Error opening definition for class {}:", sc, ClassName)
	
	#define AddCsv(%t,%l) If %l '="" {For i = 1:1:$l(%l,",") Set n=$p(%l,",",i)_%t i $e(n)'="%",'$d(..Checked(n)) Do ..AddItem(n, ClassName)}
	
	$$$AddCsv(".cls",Def.CompileAfter)
	$$$AddCsv(".cls",Def.ConstraintClass)
	$$$AddCsv(".cls",Def.DependsOn)
	$$$AddCsv(".cls",Def.EmbeddedClass)
	$$$AddCsv(".cls",Def.IndexClass)
	$$$AddCsv(".cls",Def.MemberSuper)
	$$$AddCsv(".cls",Def.ProjectionClass)
	$$$AddCsv(".cls",Def.PropertyClass)
	$$$AddCsv(".cls",Def.QueryClass)
	$$$AddCsv(".cls",Def.Super)
	$$$AddCsv(".cls",Def.TriggerClass)
	
	$$$AddCsv(".inc",Def.IncludeCode)
	$$$AddCsv(".inc",Def.IncludeGenerator)
	
	Set Package = $Piece(ClassName, ".", 1, *-1)
	
	Set key = ""
	For  {
		#dim md As %Dictionary.MethodDefinition
		Set md = Def.Methods.GetNext(.key)
		If key = "" Quit
		
		Set sc = ..CheckCode(md.Implementation, Package, ClassName)
		If 'sc Return ..BuildStatus("Error checking method {}:", sc, md.Name)
	}
	
	
	;Projections, ...
	
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="CheckCode">
<Description>
Checks code, passed as a stream, for references to classes.</Description>
<FormalSpec>Code:%Stream,Package:%String="User",ClassName=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	; Check for classmethod calls and #dim statements
	Set RegExes = $lb("##class\(([^)%]+)\)", "(?i)#dim +\w+ +As +([\w.]+)")
	
	While 'Code.AtEnd {
		Set Line = Code.ReadLine()
		If $ZStrip(Line, "<>W") = "" Continue
		
		For i = 1:1:$ll(RegExes) {
			; Get cached matcher, if already present
			Set RegEx = $li(RegExes, i)
			If ..Matchers.IsDefined(RegEx) {
				Set Matcher = ..Matchers.GetAt(RegEx)
			} Else {
				; Create matcher for this regex and add to cache
				Set Matcher = ##class(%Regex.Matcher).%New(RegEx)
				Do ..Matchers.SetAt(Matcher, RegEx)
			}
			
			; Attempt to match the current code line
			Set Matcher.Text = Line
			While Matcher.Locate() {
				Set Item = Matcher.Group(1)
				If Item '[ "." Set Item = Package_"."_Item
				Set Item = Item_".cls"
				If '$Data(..Checked(Item)) Do ..AddItem(Item, ClassName)
			}
		}
	}
	
	Quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =====

]]></Content>
</UDLText>

<Method name="AddItem">
<Description>
Adds an item to the dependency array, after checking that
it is not a system item.</Description>
<FormalSpec>Name,ClassName</FormalSpec>
<Implementation><![CDATA[
	If $Extract(Name) = "%" Quit
	If Name ? 1"Ens."1.E Quit
	If Name ? 1"EnsLib."1.E Quit
	If Name ? 1"EnsPortal."1.E Quit
	If Name ? 1"CSPX."1.E Quit
	Set ..Dependencies(Name) = ClassName
	Quit
]]></Implementation>
</Method>

<Method name="BuildStatus">
<Description>
Helper for creating updated status</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>Message:%String,Status:%Status="",Args...:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	For i = 1:1:$Get(Args) {
		Set Message = $Replace(Message, "{}", $Get(Args(i)), 1, 1)
	}
	
	;Convert message to %Status
	Set MsgStatus = $System.Status.Error($$$GeneralError, Message)
	
	;Append status from parameter, if specified
	If Status '= "" Set MsgStatus = $System.Status.AppendStatus(MsgStatus, Status)
	
	Quit MsgStatus
]]></Implementation>
</Method>
</Class>
</Export>
