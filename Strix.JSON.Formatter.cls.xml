<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Class name="Strix.JSON.Formatter">
<Description>
Formats a %DynamicAbstractObject as indented JSON.</Description>
<Super>%RegisteredObject</Super>
<TimeCreated>64382,59627.319201</TimeCreated>

<Parameter name="Indent">
<Default>2</Default>
</Parameter>

<Method name="Format">
<Description>
Entry point. Returns the JSON object converted to a formatted,
indented JSON string.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>JSON:%DynamicAbstractObject</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If JSON.%IsA("%DynamicObject") {
		Set Result = ..FormatObject(JSON)
	} ElseIf JSON.%IsA("%DynamicArray") {
		Set Result = ..FormatArray(JSON)
	}
	Quit Result
]]></Implementation>
</Method>

<Method name="FormatObject">
<Description>
Formats a %DynamicObject. Input are the array itself and the current
indentation level.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>Object:%DynamicObject,Indent:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set ThisIndent = Indent_$Justify("", ..#Indent)
	
	Set Result = "{"_$$$EOL
	
	#dim it As %Iterator.Object
	Set it = Object.%GetIterator()
	While it.%GetNext(.Name, .Value) {
		Set p = it.pointer, HasNext = it.%GetNext(), it.pointer = p
		Set Comma = $Select(HasNext: ",", 1:"")
		
		Set Type = Object.%GetTypeOf(Name)
		Set Result = Result_ThisIndent_""""_Name_""": "
		Set Result = Result_..FormatValue(Value, Type, ThisIndent)
		Set Result = Result_Comma_$$$EOL
	}
	Set Result = Result_Indent_"}"
	
	Quit Result
]]></Implementation>
</Method>

<Method name="FormatArray">
<Description>
Formats a %DynamicArray. Input are the array itself and the current
indentation level.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>Array:%DynamicArray,Indent:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set ThisIndent = Indent_$Justify("", ..#Indent)
	
	Set Result = "["_$$$EOL
	
	#dim it As %Iterator.Object
	Set it = Array.%GetIterator()
	While it.%GetNext(.Name, .Value) {
		Set p = it.pointer, HasNext = it.%GetNext(), it.pointer = p
		Set Comma = $Select(HasNext: ",", 1:"")
		
		Set Type = Array.%GetTypeOf(Name)
		Set Result = Result_ThisIndent_..FormatValue(Value, Type, ThisIndent)_Comma_$$$EOL
	}
	Set Result = Result_Indent_"]"
	
	Quit Result
]]></Implementation>
</Method>

<Method name="FormatValue">
<Description>
Formats a value in a %DynamicObject. Input are the value, the type,
and the current indent. Handles all standard %DynamicAbstractObject
types, does not handle Caché objects.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>Value:%String,Type:%String,Indent:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If Type = "string" Quit """"_..EscapeString(Value)_""""
	If Type = "boolean" Quit $Select(Value: "true", 1: "false")
	If Type = "number" Quit +Value
	If Type = "null" Quit "null"
	
	;Check if empty object
	If Type = "object" || (Type = "array") {
		Set HasData = Value.%GetIterator().%GetNext()
		If 'HasData Quit $Select(Type = "object": "{}", 1: "[]")
	}
	
	;Object types
	If Type = "object" Quit ..FormatObject(Value, Indent)
	If Type = "array" Quit ..FormatArray(Value, Indent)
	
	If Type = "oref" {
		;Caché object. Maybe a callback machanism can be used here. For now,
		;return the oref as string for now.
		Quit """"_Value_""""
	}
	
	;Fallback, we should not get here
	Quit ..EscapeString(Type_":"_Value)
]]></Implementation>
</Method>

<Method name="EscapeString">
<Description>
Escapes a string for JSON output. This means converting control characters
to Unicode escapes, and backslash-escaping double quote and backslash.
See https://tools.ietf.org/html/rfc7159#section-7.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>Input:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set Output = $Replace(Input, "\", "\\")
	Set Output = $Replace(Output, """", "\""")
	Set Output = $Replace(Output, $Char(13), "\r")
	Set Output = $Replace(Output, $Char(10), "\n")
	Set Output = $Replace(Output, $Char(9), "\t")
	
	For i = 0:1:31 {
		Set Char = $Char(i)
		If '$Find(Output, Char) Continue
		Set Escaped = "\u"_$Translate($Justify($ZHex(i), 4), " ", 0)
		Set Output = $Replace(Output, Char, Escaped)
	}
	
	Quit Output
]]></Implementation>
</Method>
</Class>
</Export>
