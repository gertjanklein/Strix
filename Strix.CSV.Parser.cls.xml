<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Class name="Strix.CSV.Parser">
<Description>
A class to parse CSV data formatted according to RFC4180.
Provides a resultset-like interface.</Description>
<IncludeCode>Strix</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>64661,63159.857904</TimeCreated>

<UDLText name="T">
<Content><![CDATA[
// ----- Input and configuration

]]></Content>
</UDLText>

<Property name="Input">
<Description>
The input data as a stream</Description>
<Type>%AbstractStream</Type>
</Property>

<Property name="Separator">
<Description>
The separator to use</Description>
<Type>%String</Type>
<InitialExpression>","</InitialExpression>
</Property>

<Property name="SkipCount">
<Description>
The number of initial (header) lines to skip on parsing</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="NamesFromFirstRow">
<Description>
Whether to take column names from the first row</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="AdaptorClassName">
<Description>
If an adaptor class exists for this CSV, specify the name here
so ..GetObject works.</Description>
<Type>%String</Type>
</Property>

<UDLText name="T">
<Content><![CDATA[
// ----- State

]]></Content>
</UDLText>

<Property name="RecordNr">
<Description>
The number of the current record. This includes header rows,
if any.</Description>
<Type>%Integer</Type>
</Property>

<Property name="Names">
<Description>
Optional mapping of column name to column index</Description>
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="Data">
<Description>
The data indexed by column number</Description>
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="DataByName">
<Description>
The data indexed by column name</Description>
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<UDLText name="T">
<Content><![CDATA[
// =====

]]></Content>
</UDLText>

<Method name="GetParser">
<Description>
Returns an instance of this class with some properties setup.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>Input:%AbstractStream,Separator:%String=",",SkipCount:%Integer=0,ColumnNames:%String</FormalSpec>
<ReturnType>Strix.CSV.Parser</ReturnType>
<Implementation><![CDATA[
	Set Me = ..%New()
	Set Me.Input = Input
	Set Me.Separator = Separator
	Set Me.SkipCount = SkipCount
	If SkipCount = 1, '$Data(ColumnNames) Set Me.NamesFromFirstRow = 1
	If $Get(ColumnNames) '= "" Do Me.SetColumnNames(ColumnNames)
	Quit Me
]]></Implementation>
</Method>

<Method name="Next">
<Description>
Get the next record. Returns 0 if no more records available.</Description>
<FormalSpec>*Status:%Status</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	For  {
		Set ok = ..GetRecord(.Status)
		If 'ok Quit
		
		; Got record; load names if needed
		
		Set ..RecordNr = ..RecordNr + 1
		If ..RecordNr = 1, ..NamesFromFirstRow Do ..SetColumnNamesFromData()
		If ..RecordNr '> ..SkipCount Continue
		
		; Load ..DataByName
		
		Kill ..DataByName
		Set Name = ""
		For  {
			Set Name = $Order(..Names(Name), 1, Index)
			If Name = "" Quit
			If '$Data(..Data(Index)) Continue
			Set ..DataByName(Name) = ..Data(Index)
		}
		
		Quit
	}
	If 'ok Quit 0
	
	Quit 1
]]></Implementation>
</Method>

<Method name="Get">
<Description>
Returns the data in the specified column for the current record.
Parameter Default specifies what to return if a column is requested
that wasn't present in the input.</Description>
<CodeMode>expression</CodeMode>
<FormalSpec>ColumnNr:%Integer,Default:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$Get(i%Data(ColumnNr), Default)
]]></Implementation>
</Method>

<Method name="GetByName">
<Description>
Returns the data in the column, specified by name, for the current
record. If no column with that name is present, or if no data was
supplied for it, returns the default value.</Description>
<FormalSpec>ColumnName:%String,Default:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set ColumnNr = $Get(..Names(ColumnName))
	If ColumnNr = "" Quit Default
	Quit $Get(..Data(ColumnNr), Default)
]]></Implementation>
</Method>

<Method name="GetAsList">
<Description>
Returns the row as a %List.</Description>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
	Set List = ""
	For i = 1:1:..Data {
		Set List = List_$ListBuild(..Data(i))
	}
	Quit List
]]></Implementation>
</Method>

<Method name="GetObject">
<Description>
If an adaptor class has been created for this CSV (and ..AdaptorClassName
has been set), this method returns an instance of that class for the
current record.</Description>
<FormalSpec>*Status:%Status</FormalSpec>
<ReturnType>Strix.CSV.Adaptor</ReturnType>
<Implementation><![CDATA[
	Set Status = $$$OK
	
	#dim Adaptor As Strix.CSV.Adaptor
	Set Adaptor = $ZObjClassMethod(..AdaptorClassName, "%New")
	If Adaptor = "" Quit $$$BuildStatus("Error creating instance of '{}':", $Get(%objlasterror), ..AdaptorClassName)
	
	Merge Data = ..DataByName
	Set Status = Adaptor.LoadCSVData(.Data)
	
	Quit Adaptor
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =====

]]></Content>
</UDLText>

<Method name="SetColumnNames">
<Description>
Sets the column names to use for method GetByName. Specify as a
string, the separator defaults to ..Separator but can be overridden.</Description>
<FormalSpec>Names:%String,Separator:%String=""</FormalSpec>
<Implementation><![CDATA[
	If Separator = "" Set Separator = ..Separator
	
	For ColumnNr = 1:1:$Length(Names, Separator) {
		Set Name = $ZStrip($Piece(Names, Separator, ColumnNr), "<>W")
		;Name is not required to be present
		If Name = "" Continue
		Set ..Names(Name) = ColumnNr
	}
	
	Quit
]]></Implementation>
</Method>

<Method name="SetColumnNamesFromData">
<Description>
Sets column names from the data in ..Data.</Description>
<Implementation><![CDATA[
	For ColumnNr = 1:1:..Data {
		Set ColumnName = $ZStrip(..Data(ColumnNr), "<>W")
		If ColumnName = "" Set ColumnName = "__"_ColumnNr
		Set ..Names(ColumnName) = ColumnNr
	}
	Quit
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// ===== Private helper code

]]></Content>
</UDLText>

<Method name="GetRecord">
<Description>
Retrieve the next record from the input stream. If no more records
are present, returns false. In case of quoted fields, a record may
span multiple lines. Returns parsing errors, if any, in output
parameter Status.</Description>
<FormalSpec>*Status:%Status</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set Status = $$$OK
	Kill ..Data Set ..Data = 0
	If ..Input.AtEnd Quit 0
	
	Set Line = ..Input.ReadLine( , .Status)
	If 'Status Quit 0
	If Line = "", ..Input.AtEnd Quit 0
	
	; If no quotes data can't span multiple lines or contain separator
	
	If Line '[ """" {
		If Line = "" Quit 1
		Set ..Data = $Length(Line, ..Separator)
		For i = 1:1:..Data {
			Set ..Data(i) = $Piece(Line, ..Separator, i)
		}
		Quit 1
	}
	
	; Quotes present, more elaborate parsing needed.
	
	Set Index = 1
	For  {
		; Check the first char of the record data
		
		Set Char = $Extract(Line, Index)
		If Char = "" {
			; No more data, we're done
			
			Set ..Data($Increment(..Data)) = ""
			Quit
			
		} ElseIf Char = """" {
			; Quoted field, looking for a closing quote
			
			Set Index = Index + 1
			Set FieldData = ""
			For  {
				Set Test = $Find(Line, """", Index)
				If Test = 0 {
					; No closing quote in the rest of this line; append another
					If ..Input.AtEnd {
						Set Msg = "Parsing error: end of data while looking for closing quote in record {}."
						Set Status = $$$BuildStatus(Msg, , ..RecordNr+1)
						Return 0
					}
					Set NextLine = ..Input.ReadLine( , .Status)
					If 'Status Return 0
					Set Line = Line_..Input.LineTerminator_NextLine
					Continue
				}
				
				; Found quote; check next character
				Set NextChar = $Extract(Line, Test)
				If NextChar = "" {
					; End of line: this is the last field
					Set FieldData = FieldData_$Extract(Line, Index, Test-2)
					Set ..Data($Increment(..Data)) = FieldData
					Return 1
				}
				If NextChar = """" {
					; Quote: escaped quote, save and search on
					Set FieldData = FieldData_$Extract(Line, Index, Test-2)_""""
					Set Index = Test + 1
					Continue
				}
				If NextChar = ..Separator {
					; Separator: this was the end of this field
					Set FieldData = FieldData_$Extract(Line, Index, Test-2)
					Set ..Data($Increment(..Data)) = FieldData
					Set Index = Test + 1
					Quit
				}
				
				;Char after "closing" quote should be nothing, quote, or separator
				Set Msg = "Parsing error: lone quote in quoted field at record {}, character {}."
				Set Status = $$$BuildStatus(Msg, , ..RecordNr+1, Test-1)
				Return 0
			}
			
		} ElseIf Char = ..Separator {
			; At the start of the next field, this one is empty
			
			Set ..Data($Increment(..Data)) = ""
			Set Index = Index + 1
			
		} Else {
			; Normal data, look for next separator (ignoring quotes)
			
			Set Test = $Find(Line, ..Separator, Index+1)
			If Test = 0 {
				; No more fields
				Set ..Data($Increment(..Data)) = $Extract(Line, Index, *)
				Quit
			} Else {
				; Found start of next field
				Set ..Data($Increment(..Data)) = $Extract(Line, Index, Test-2)
				Set Index = Test
			}
			
		}
	}
	
	Quit 1
]]></Implementation>
</Method>
</Class>
</Export>
