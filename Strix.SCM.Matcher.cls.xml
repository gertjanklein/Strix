<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Class name="Strix.SCM.Matcher">
<Description>
Matches item patterns.</Description>
<IncludeCode>Strix.SCM</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>63688,45811.150382</TimeCreated>

<Property name="SpecList">
<Description>
Item specifications to match against</Description>
<Type>%String</Type>
<Collection>list</Collection>
</Property>

<Property name="Patterns">
<Description>
The patterns generated from the specs, for re-use</Description>
<Type>%String</Type>
<Collection>array</Collection>
</Property>

<UDLText name="T">
<Content><![CDATA[
// =====

]]></Content>
</UDLText>

<Method name="%OnNew">
<Description>
Constructor, pass in the list of project member specifications</Description>
<FormalSpec>SpecList:%ListOfDataTypes=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	If SpecList Set ..SpecList = SpecList
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="Matches">
<Description>
Returns a boolean indicating whether an item matches any of the specs here.</Description>
<FormalSpec>Item:%String,*AsItem:%Boolean,*AsStorage:%Boolean</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set (AsItem, AsStorage) = 0
	
	;Convert type to lowercase
	$$$NormalizeType(Item)
	Set ItemType = $$$ItemType(Item)
	
	If ItemType = "cls" {
		;If this is a generated class, ignore it
		If $$$defClassKeyGet($$$ItemName(Item),$$$cCLASSgeneratedby) '= "" Quit 0
	}
	
	
	;Treat BPL and DTL types as the classes they are
	If "bpl,dtl" [ ItemType Set $$$ItemType(Item) = "cls"
	
	;First check the negative specifications: if one of them matches we must
	;reject this item.
	Set Found = 0
	For i = 1:1:..SpecList.Count() {
		Set Spec = ..SpecList.GetAt(i)
		If $Extract(Spec) '= "-" Continue
		If $$$ItemType(Spec) = "gbl" Continue
		
		Set Pattern = ..MakePattern(Spec)
		If Item ?@Pattern Set Found = 1 Quit
	}
	If 'Found {
		;No negative spec found; check the positive specifications
		For i = 1:1:..SpecList.Count() {
			Set Spec = ..SpecList.GetAt(i)
			If $Extract(Spec) = "-" Continue
			If $$$ItemType(Spec) = "stg" Continue
			
			Set Pattern = ..MakePattern(Spec)
			If Item ?@Pattern Set Found = 1 Quit
		}
		If Found Set AsItem = 1
	}
	
	;=====
	
	;Check storage:
	Set Found = 0
	For i = 1:1:..SpecList.Count() {
		Set Spec = ..SpecList.GetAt(i)
		If $Extract(Spec) '= "-" Continue
		If $$$ItemType(Spec) '= "gbl" Continue
		
		Set $Piece(Spec, ".", $Length(Spec, ".")) = "cls"
		Set Pattern = ..MakePattern(Spec)
		If Item ?@Pattern Set Found = 1 Quit
	}
	If 'Found {
		;No negative spec found; check the positive specifications
		For i = 1:1:..SpecList.Count() {
			Set Spec = ..SpecList.GetAt(i) 
			If $Extract(Spec) = "-" Continue
			If $$$ItemType(Spec) '= "stg" Continue
			
			Set $Piece(Spec, ".", $Length(Spec, ".")) = "cls"
			Set Pattern = ..MakePattern(Spec)
			If Item ?@Pattern Set Found = 1 Quit
		}
		If Found Set AsStorage = 1
	}
	
	Quit AsItem || AsStorage
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =====

]]></Content>
</UDLText>

<Method name="GetAllMembers">
<Description>
Build an array of all current items matching the specifications
in ..SpecList.</Description>
<FormalSpec>*Members:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	;First convert all specs to patterns
	For i = 1:1:..SpecList.Count() {
		Set Spec = ..SpecList.GetAt(i)
		Set Pattern = ..MakePattern($Select($Extract(Spec) = "-": $Extract(Spec, 2, *), 1: Spec))
		Do ..Patterns.SetAt(Pattern, Spec)
	}
	
	;Get a unique node to use for temporary storage of the class list
	Set Node = $Name(^||Matcher($Increment(^||Matcher)))
	Kill @Node
	
	;Preload a list of all classes, assuming most specs are classes
	Set Status = ..GetAllClasses(Node)
	If 'Status Quit $$$BuildErr("Error getting classlist", Status)
	
	;Start with the add specs:
	Set Spec = ""
	For  {
		Set Pattern = ..Patterns.GetNext(.Spec)
		If Spec = "" Quit
		If $Extract(Spec) = "-" Continue
		
		Set Type = $$$ItemType(Spec)
		If Type = "cls" {
			;Class names are matched with the pattern
			Set Status = ..HandleClassSpec(Node, Pattern, .Members)
			
		} ElseIf (Type = "mac") || (Type = "inc") || (Type = "int") {
			;Routine names are handled using the spec
			Set Status = ..HandleRoutineSpec(Spec, .Members)
			
		} ElseIf Type = "stg" {
			Set Status = ..HandleStorageSpec(Node, Spec, Pattern, .Members)
			
		}
		If 'Status Quit
	}
	If 'Status Quit $$$BuildErr("Error handling spec '"_Spec_"'", Status)
	
	
	;Now remove everything matching the remove specs:
	Set Spec = ""
	For  {
		Set Pattern = ..Patterns.GetNext(.Spec)
		If Spec = "" Quit
		If $Extract(Spec) '= "-" Continue
		
		Set Type = $$$ItemType(Spec)
		Set Name = ""
		For  {
			Set Name = $Order(Members(Name), 1, Type)
			If Name = "" Quit
			
			If Name '? @Pattern Continue
			Kill Members(Name)
		}
	}
	
	Quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// ===== Helpers

]]></Content>
</UDLText>

<Method name="HandleClassSpec">
<Description>
Parses the specification for items of type cls, and stores
the result in Members.</Description>
<FormalSpec><![CDATA[Node:%String,Pattern:%String,&Members:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set Name = ""
	For  {
		Set Name = $Order(@Node@(Name))
		If Name = "" Quit
		
		If Name '? @Pattern Continue
		
		Set Members(Name) = ""
	}
	
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="HandleRoutineSpec">
<Description>
Parses the specification for items of type mac, int, and inc, and stores
the result in Members.</Description>
<FormalSpec><![CDATA[Spec:%String,&Members:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set rs = ##class(%ResultSet).%New("%Routine:RoutineList")
	Set Status = rs.Execute(Spec)
	If 'Status Quit $$$BuildErr("Error executing routine query with spec '"_Spec_"':", Status)
	
	While rs.Next() {
		Set Name = rs.Get("Name")
		;Convert type (mac, inc, etc) to lowercase
		$$$NormalizeType(Name)
		Set Members(Name) = ""
	}
	
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="HandleStorageSpec">
<Description>
Parses the specification for items of type stg (storage), and stores the
result in Members.</Description>
<FormalSpec><![CDATA[Node:%String,Spec:%String,Pattern:%String,&Members:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	;The pattern ends in .stg, but we are looking for classes
	If Pattern '? 1.E1".stg""" Quit $$$BuildErr("Pattern spec error: '"_Pattern_"'", 1)
	Set $Extract(Pattern, *-4, *) = ".cls"""
	
	Set Status = $$$OK
	Set Name = ""
	For  {
		Set Name = $Order(@Node@(Name))
		If Name = "" Quit
		
		If Name '? @Pattern Continue
		
		Set StgName = Name, $Extract(StgName, *-3, *) = ".stg"
		
		Set Members(StgName) = ..GetStorageGlobals(Name, .Status)
		If 'Status Set Status = $$$BuildErr("Error getting storage location for class '"_Name_"' included by spec '"_Spec_"'", Status) Quit
	}
	If 'Status Quit Status
	
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetStorageGlobals">
<Description>
Returns the globals used for a class's storage (if specified in the
standard Cach√© manner -- custom storage is not supported).</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>ClassName:%String,*Status:%Status</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If ClassName ?1.E1".cls" Set ClassName = $Extract(ClassName, 1, *-4)
	
	#dim Def As %Dictionary.ClassDefinition
	Set Def = ##class(%Dictionary.ClassDefinition).%OpenId(ClassName, , .Status)
	If 'Status Set Status = $$$BuildErr("Can't determine storage globals for class '"_ClassName_"'", Status) Quit ""
	
	Set Key = ""
	For  {
		#dim Storage As %Dictionary.StorageDefinition
		Set Storage = Def.Storages.GetNext(.Key)
		If Key = "" Quit
		
		If Storage.Type '= "%Library.CacheStorage" {
			Set Status = $$$BuildErr("Unsupported storage type '"_Storage.Type_"'", 1)
			Quit
		}
		
		;Store in array to remove duplicates
		Set Globals(Storage.DataLocation_".gbl") = ""
		Set Globals(Storage.IdLocation_".gbl") = ""
		Set Globals(Storage.IndexLocation_".gbl") = ""
		Set Globals(Storage.StreamLocation_".gbl") = ""
	}
	If 'Status Quit ""
	
	;Convert array to comma-separated list
	Set Result = ##class(Strix.Lib.String).ListFromArray(.Globals, ",")
	
	Quit Result
]]></Implementation>
</Method>

<Method name="GetAllClasses">
<Description>
Determines all available classes</Description>
<FormalSpec>Node:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set rs = ##class(%ResultSet).%New("%Dictionary.ClassDefinitionQuery:Summary")
	Set Status = rs.Execute()
	If 'Status Quit $$$BuildErr("Error executing all classes query:", Status)
	
	While rs.Next() {
		If rs.Get("Hidden") Continue
		If rs.Get("System") Continue
		If rs.Get("Generated") Continue
		
		Set ClassName = rs.Get("Name")
		
		;Skip Ensemble system classes -- these are not marked System in this query. :(
		Set TopPackage = $Piece(ClassName, ".")
		If TopPackage = "Ens" Continue
		If TopPackage = "EnsLib" Continue
		If TopPackage = "EnsPortal" Continue
		
		Set @Node@(ClassName_".cls") = ""
	}
	
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="MakePattern">
<Description>
Converts a specification containing optional asterisks (*) as match-all
character to a corresponding COS pattern.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>Specification:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	;Remove negation, will be handled elsewhere
	If $Extract(Specification) = "-" Set Specification = $Extract(Specification, 2, *)
	
	Set Pattern = ""
	Set Index = 0, PrevIndex = 1
	For  {
		Set Index = $Find(Specification, "*", Index)
		If Index {
			;Found an asterisk; take everything before it literal
			Set Before = $Extract(Specification, PrevIndex, Index - 2)
			If Before '= "" Set Pattern = Pattern_"1"""_Before_""""
			Set Pattern = Pattern_".E"
			Set PrevIndex = Index
			
		} Else {
			Set LastBit = $Extract(Specification, PrevIndex, $Length(Specification))
			If LastBit '= "" Set Pattern = Pattern_"1"""_LastBit_""""
			
			Quit
		}
	}
	
	Quit Pattern
]]></Implementation>
</Method>
</Class>
</Export>
