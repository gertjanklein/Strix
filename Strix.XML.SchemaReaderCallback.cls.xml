<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Class name="Strix.XML.SchemaReaderCallback">
<IncludeCode>Strix</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>65045,38962.002691</TimeCreated>

<Property name="Reader">
<Description>
The reader we receive the callback from</Description>
<Type>Strix.XML.SchemaReader</Type>
</Property>

<UDLText name="T">
<Content><![CDATA[
// -----

]]></Content>
</UDLText>

<Property name="ClassName">
<Description>
Name of the currently handled class</Description>
<Type>%String</Type>
</Property>

<Property name="ClassNode">
<Description>
Global node containing the class information</Description>
<Type>%String</Type>
</Property>

<Property name="PropertyName">
<Description>
Name of the currently handled property</Description>
<Type>%String</Type>
</Property>

<Property name="PropertyNode">
<Description>
Global node containing the property information</Description>
<Type>%String</Type>
</Property>

<UDLText name="T">
<Content><![CDATA[
// =====

]]></Content>
</UDLText>

<Method name="Create">
<Description>
Template entry point; intended to be overridden and completed
in a subclass.</Description>
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<FormalSpec>Package:%String="temp"</FormalSpec>
<Implementation><![CDATA[
	; Get class creation times of currently existing classes in Package
	Set sc = ..GetTimes(Package, .Times)
	If 'sc Quit ..ShowError("Error determining class creation times:", sc)
	
	;;
	;; Optional: create %SOAP.WSDL.Reader here for WSDL processing
	;;
	
	; Create schema reader
	Set sr = ##class(Strix.XML.SchemaReader).%New()
	Set sr.Callback = ..%New()
	
	;;
	;; Configure and process, either SOAP reader or schema reader
	;;
	
	; Restore class creation time for classes that still exist
	Set sc = ..UpdateTimes(Package, .Times)
	If 'sc Quit ..ShowError("Error updating class creation times:", sc)
	
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="HandleClass">
<Description>
Overridable method: handles a single class.</Description>
<FormalSpec>Name:%String,XmlName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="HandleProperty">
<Description>
Overridable method: handles a single property.</Description>
<FormalSpec>Name:%String,XmlName:%String,Type:%String,IsDataType:%Boolean</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// ===== Helpers

]]></Content>
</UDLText>

<Method name="GetValidName">
<Description>
Receives a class short name or property name and its XML name,
and returns what it should be named.</Description>
<FormalSpec>Name:%String,XmlName:%String,*Changed:%Boolean</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set Changed = 0
	If $ZName(XmlName, 6) Quit XmlName
	
	Set NewName = ""
	For i = 1:1:$Length(XmlName) {
		Set Char = $Extract(XmlName, i)
		If " _.(-" [ Char, $Extract(XmlName, i+1) ? 1A {
			Set NewName = NewName_$ZConvert($Extract(XmlName, $Increment(i)), "U")
			Continue
		}
		
		If NewName '= "" {
			;Valid as second or later character?
			If $ZName("x"_Char, 6) Set NewName = NewName_Char
		} Else {
			;Valid as first character?
			If $ZName(Char, 6) Set NewName = NewName_Char
		}
	}
	
	Set Changed = Name '= NewName
	
	Quit NewName
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// -----

]]></Content>
</UDLText>

<Method name="RenameClass">
<Description>
Changes the name of the current class.</Description>
<FormalSpec>NewName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	; Allow providing new name without package
	If NewName '[ "." {
		Set Package = $Piece(..ClassName, ".", 1, *-1)
		Set NewName = Package_"."_NewName
	}
	
	; Make sure XML name stays the same
	If '$Data(@..ClassNode@("Parameter", "XMLNAME")) {
		Set ShortName = $Piece(..ClassName, ".", *)
		Set @..ClassNode@("Parameter", "XMLNAME") = ShortName
	}
	
	; Change class name
	Set @..ClassNode@("ClassName") = NewName
	Set ..ClassName = NewName
	
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="RemoveClass">
<Description>
Removes the current class; it won't be created.</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set @..ClassNode@("Removed") = 1
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="SetClassParameter">
<Description>
Sets a parameter for the current class</Description>
<FormalSpec>Name:%String,Value:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set @..ClassNode@("Parameter", Name) = Value
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetSuperClass">
<Description>
Returns the superclass for the currently processed class</Description>
<FormalSpec>*NamespaceIdx:%Integer</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set Info = $Get(@..ClassNode@("Super"))
	If Info ? 1.N1"^".E {
		Set NamespaceIdx = $Piece(Info, "^", 1)
		Set SuperClass = $Piece(Info, "^", 2)
	} Else {
		Set NamespaceIdx = ""
		Set SuperClass = Info
	}
	Quit SuperClass
]]></Implementation>
</Method>

<Method name="SetSuperClass">
<Description>
Changes the superclass for the currently processed class</Description>
<FormalSpec>SuperClass:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set @..ClassNode@("Super") = SuperClass
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetClassType">
<Description>
Retrieves the type of the current class. Output parameter
NamespaceIdx receives the index in the schemareader ..NSInfo
property for the class.</Description>
<FormalSpec>*NamespaceIdx:%Integer</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set Info = $Get(@..ClassNode@("Type"))
	Set NamespaceIdx = $Piece(Info, "^", 1)
	Set Type = $Piece(Info, "^", 2)
	Set Ref = $Piece(Info, "^", 3)
	
	If Info ?1"^^"1.N {
		; Reference to another node; get the classname from there:
		Set ClassBase = $Name(@..ClassNode, $QLength(..ClassNode)-1)
		Set Type = @ClassBase@(Ref, "ClassName")
	}
	
	Quit Type
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// -----

]]></Content>
</UDLText>

<Method name="RenameProperty">
<Description>
Changes the name of the current property.</Description>
<FormalSpec>NewName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	; Make sure XML name stays the same
	If '$Data(@..PropertyNode@("Parameter", "XMLNAME")) {
		Set @..PropertyNode@("Parameter", "XMLNAME") = ..PropertyName
	}
	
	; Change property name
	Set @..PropertyNode@("Name") = NewName
	
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="SetPropertyParameter">
<Description>
Sets a property parameter for the current class</Description>
<FormalSpec>Name:%String,Value:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set @..PropertyNode@("Parameter", Name) = Value
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="SetPropertyRequired">
<Description>
Sets a property required flag</Description>
<FormalSpec>Required:%Boolean=1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set @..PropertyNode@("Required") = Required
	Quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// ===== Additional helpers

]]></Content>
</UDLText>

<Method name="GetTimes">
<Description>
Load the creation times of all classes in Package, and return them
in output parameter Times. This can be used in conjunction with
the UpdateTimes method, to persist class creation times through
subsequent runs of the schemareader (which deletes the classes
before recreating them). This is useful to prevent source code diffs
showing changes when there aren't.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>Package:%String,Times:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $System.OBJ.GetPackageList(.Items, Package, "/includesubpackages")
	If 'sc Quit $$$BuildStatus("Error loading list of existing classes in {}:", Status, Package)
	Set ClassName = ""
	For  {
		Set ClassName = $Order(Items(ClassName))
		If ClassName = "" Quit
		Set Time = $$$defClassKeyGet(ClassName, $$$cCLASStimecreated)
		Set Times(ClassName) = Time
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="UpdateTimes">
<Description>
Update the class creation time for classes in Package, if this
information is present in the Times array. Expected to be used
with the output of the GetTimes method.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>Package:%String,Times:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $System.OBJ.GetPackageList(.Items, Package, "/includesubpackages")
	If 'sc Quit $$$BuildStatus("Error loading list of existing classes in {}:", Status, Package)
	Set ClassName = ""
	For  {
		Set ClassName = $Order(Items(ClassName))
		If ClassName = "" Quit
		If '$Data(Times(ClassName)) Continue
		$$$defClassKeySet(ClassName, $$$cCLASStimecreated, Times(ClassName))
	}
	Quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// -----

]]></Content>
</UDLText>

<Method name="ShowError">
<Description>
Displays an error message and/or %Status.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>Message:%String="",Status:%Status="",Args...</FormalSpec>
<Implementation><![CDATA[
	If $Get(Args) Set Message = $$$BuildStr(Message, Args...)
	If Message '= "", Status '= "" {
		Write Message_":",!
		Do $System.Status.DisplayError(Status)
	} ElseIf Message '= "" {
		Write Message,!
	} Else {
		Do $System.Status.DisplayError(Status)
	}
	Quit 0
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// ===== Internal =====

]]></Content>
</UDLText>

<Method name="ProcessParseTree">
<Description>
Callback from schema reader. Called after parsing is done, and
before any classes are created. Gets passed the name of the
global node that contains the classes part of the parse tree.</Description>
<Internal>1</Internal>
<FormalSpec>ClassTree:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	; Loop through generated classes
	Set ckey = ""
	For  {
		Set ckey = $Order(@ClassTree@(ckey))
		If ckey = "" Quit
		
		Set ..ClassNode = $Name(@ClassTree@(ckey))
		If $Get(@..ClassNode@("Removed")) Continue
		
		Set ..ClassName = $Get(@..ClassNode@("ClassName"))
		
		Set sc = ..ProcessClassNode(..ClassName)
		If 'sc Return $$$BuildStatus("Error processing class '{}':", sc, ..ClassName)
	}
	
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ProcessClassNode">
<Description>
Called by PostProcessParseTree for each class.</Description>
<Internal>1</Internal>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set (..PropertyName, ..PropertyNode) = ""
	
	; Call basic callback method
	Set XmlName = $Get(@..ClassNode@("Parameter", "XMLNAME"), Name)
	
	; Handle Xml to Caché name conversion here
	Set Name = ..GetValidName($Piece(Name, ".", *), XmlName, .Changed)
	If Changed Do ..RenameClass(Name)
	
	Set sc = ..HandleClass(Name, XmlName)
	If 'sc Quit $$$BuildStatus("Error handling class '{}':", sc, ..ClassName)
	
	; Loop through properties
	For pkey = 1:1:$Get(@..ClassNode@("Property")) {
		Set ..PropertyNode = $Name(@..ClassNode@("Property", pkey))
		Set (..PropertyName, PropertyName) = @..PropertyNode@("Name")
		
		Set Type = ..Reader.TypeToClass($Get(@..PropertyNode@("Type")), .IsDatatype)
		Set XmlName = $Get(@..PropertyNode@("Parameter", "XMLNAME"), PropertyName)
		
		; Handle Xml to Caché name conversion here
		Set PropertyName = ..GetValidName(PropertyName, XmlName, .Changed)
		If Changed Do ..RenameProperty(PropertyName)
		
		Set sc = ..HandleProperty(..PropertyName, XmlName, Type, IsDatatype)
		If 'sc Return $$$BuildStatus("Error handling property {}:", sc, ..PropertyName)
	}
	
	Quit $$$OK
]]></Implementation>
</Method>
</Class>
</Export>
