<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Class name="Strix.Generator.Utilities">
<Description>
Utility code for generator methods in other classes.</Description>
<IncludeCode>Strix</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>62935,33467.821661</TimeCreated>

<Method name="GetClassDef">
<Description>
Helper: opens a class definition or returns a new one with the specified name.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String,*IsNew:%Boolean,*Status:%Status</FormalSpec>
<ReturnType>%Dictionary.ClassDefinition</ReturnType>
<Implementation><![CDATA[
	If ##class(%Dictionary.ClassDefinition).%ExistsId(Name) {
		Set ClassDef = ##class(%Dictionary.ClassDefinition).%OpenId(Name, , .Status)
		Set IsNew = 0
	} Else {
		; Set classversion to 25 to prevent prodedureblock and inheritance
		; getting old default values (off and right, respectively).
		Set ClassDef = ##class(%Dictionary.ClassDefinition).%New(Name, 25)
		Set IsNew = 1, Status = $$$OK
	}
	Quit ClassDef
]]></Implementation>
</Method>

<Method name="GetOrderedList">
<Description>
Returns a copy of a collection, expected to consist of class definition
members, ordered by their SequenceNumber property. This is the order in
which they are shown in Studio.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>Collection:%RelationshipObject,*Status:%Status</FormalSpec>
<ReturnType>%Collection.AbstractIterator</ReturnType>
<Implementation><![CDATA[
	Set Result = ##class(Strix.Lib.Collections).GetCopy(Collection, 1, .Status)
	If 'Status Quit Result
	Set Status = ##class(Strix.Lib.Sorting).SortListOfObjects(Result, "SequenceNumber")
	Quit Result
]]></Implementation>
</Method>

<Method name="GetInCollection">
<Description>
Returns an item, specified by name, from a relationship collection
(such as CompiledClass:Properties, etc.).</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>Collection:%RelationshipObject,Name:%String,Create:%Boolean=0,*Status:%Status</FormalSpec>
<ReturnType>%RegisteredObject</ReturnType>
<Implementation><![CDATA[
	Set Status = $$$OK
	
	Set Found = 0
	Set Key = ""
	For  {
		Set Object = Collection.GetNext(.Key)
		If Key = "" Quit
		If Object.Name = Name Set Found = 1 Quit
	}
	If Found Quit Object
	
	If 'Create Quit ""
	
	Set Object = $ZObjClassMethod(Collection.ElementType, "%New")
	Set Object.Name = Name
	Set Status = Collection.Insert(Object)
	
	Quit Object
]]></Implementation>
</Method>

<Method name="GetParameter">
<Description>
Returns a ParameterDefinition (or CompiledParameter) object with the
specified name, if present. ClassNameOrObj can be either a class name
or a class definition object.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>ClassNameOrObj:%Dictionary.ClassDefinition,ParameterName:%String,*ParameterDefinition:%Dictionary.ParameterDefinition</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If '$IsObject(ClassNameOrObj) {
		;Not an object, so a class name
		Set ClassNameOrObj = ##class(%Dictionary.CompiledClass).%OpenId(ClassNameOrObj, , .sc)
		If 'sc Quit sc
	}
	
	Set Key = ""
	For  {
		Set ParameterDefinition = ClassNameOrObj.Parameters.GetNext(.Key)
		If Key = "" Quit
		If ParameterDefinition.Name = ParameterName Quit
	}
	
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetParameterValue">
<Description>
Shortcut method to quickly retrieve a parameter value. Returns an empty string
in case the parameter doesn't exist or an error occurs.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>ClassNameOrObj:%Dictionary.ClassDefinition,ParameterName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set sc = ..GetParameter(ClassNameOrObj, ParameterName, .ParameterDefinition)
	If 'sc Quit ""
	If '$IsObject(ParameterDefinition) Quit ""
	Quit ParameterDefinition.Default
]]></Implementation>
</Method>

<Method name="GetProperty">
<Description>
Returns a PropertyDefinition (or CompiledProperty) object with the
specified name, if present. ClassNameOrObj can be either a class name
or a class definition object.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>ClassNameOrObj:%Dictionary.ClassDefinition,PropertyName:%String,*PropertyDefinition:%Dictionary.PropertyDefinition</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set PropertyDefinition = ""
	If '$IsObject(ClassNameOrObj) {
		;Not an object, so a class name
		Set ClassNameOrObj = ##class(%Dictionary.ClassDefinition).%OpenId(ClassNameOrObj, , .sc)
		If 'sc Quit sc
	}
	
	Set Key = "", Found = 0
	For  {
		Set PropertyDefinition = ClassNameOrObj.Properties.GetNext(.Key)
		If Key = "" Quit
		If PropertyDefinition.Name = PropertyName Set Found = 1 Quit
	
	}
	If 'Found Quit $$$ERROR($$$GeneralError, "Property "_PropertyName_" not found.")
	
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetIndexDefinition">
<Description>
Returns the global the indices for this class reside in.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>ClassNameOrObj:%Dictionary.ClassDefinition,IndexName:%String,*IndexDefinition:%Dictionary.IndexDefinition</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set IndexDefinition = ""
	If '$IsObject(ClassNameOrObj) {
		;Not an object, so a class name
		Set ClassNameOrObj = ##class(%Dictionary.ClassDefinition).%OpenId(ClassNameOrObj, , .sc)
		If 'sc Quit sc
	}
	
	Set Key = "", Found = 0
	For  {
		Set IndexDefinition = ClassNameOrObj.Indices.GetNext(.Key)
		If Key = "" Quit
		
		If IndexDefinition.Name = IndexName Set Found = 1 Quit
	}
	If 'Found Quit $$$ERROR($$$GeneralError, "Property "_IndexName_" not found.")
	
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetIndexLocation">
<Description>
Returns the global the indices for this class reside in.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>ClassNameOrObj:%Dictionary.ClassDefinition,*IndexLocation:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set IndexLocation = ""
	
	If '$IsObject(ClassNameOrObj) {
		;Not an object, so a class name
		Set ClassNameOrObj = ##class(%Dictionary.ClassDefinition).%OpenId(ClassNameOrObj, , .sc)
		If 'sc Quit sc
	}
	
	Set Key = ""
	For  {
		Set StorageDef = ClassNameOrObj.Storages.GetNext(.Key)
		If Key = "" Quit
		
		Set IndexLocation = StorageDef.IndexLocation
		Quit
	}
	
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetMethod">
<Description>
Returns a MethodDefinition (or CompiledMethod) object with the
specified name, if present. ClassNameOrObj can be either a class name
or a class definition object.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>ClassNameOrObj:%Dictionary.ClassDefinition,MethodName:%String,*MethodDefinition:%Dictionary.MethodDefinition</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set MethodDefinition = ""
	If '$IsObject(ClassNameOrObj) {
		;Not an object, so a class name
		Set ClassNameOrObj = ##class(%Dictionary.ClassDefinition).%OpenId(ClassNameOrObj, , .sc)
		If 'sc Quit sc
	}
	
	Set Key = "", Found = 0
	For  {
		Set MethodDefinition = ClassNameOrObj.Methods.GetNext(.Key)
		If Key = "" Quit
		If MethodDefinition.Name = MethodName Set Found = 1 Quit
	
	}
	If 'Found Quit $$$ERROR($$$GeneralError, "Method "_MethodName_" not found.")
	
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="HasConcreteMethod">
<Description>
Returns whether the given method is present and non-abstract.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>ClassDef:%Dictionary.CompiledClass,MethodName:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	If '$IsObject(ClassDef) Set ClassDef = ..GetClassDef(ClassDef)
	Set Method = ..GetInCollection(ClassDef.Methods, MethodName)
	If Method = "" Quit 0
	Quit 'Method.Abstract
]]></Implementation>
</Method>

<Method name="IsDatatype">
<Description>
Attempts to determine if the given property is a datatype. Non-datatype
properties have a few extra system-generated methods such as
[Property]SetObjectId. ClassNameOrObj can be either a class name or a
class definition object.
</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>ClassNameOrObj:%Dictionary.ClassDefinition,PropertyName:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	#dim PropDef As %Dictionary.PropertyDefinition
	Set sc = ..GetProperty(ClassNameOrObj, PropertyName, .PropDef)
	If 'sc Quit 1
	
	Set Type = PropDef.Type
	If Type = "" Quit 1
	
	Quit ..ClassIsDataType(Type)
]]></Implementation>
</Method>

<Method name="ClassIsDataType">
<Description>
Returns a flag indicating whether a class can be determined to be a datatype.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>ClassName:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set ClassName = $$$NormalizeClassname(ClassName)
	&sql(SELECT Super INTO :Super FROM %Dictionary.ClassDefinition WHERE Name = :ClassName)
	If SQLCODE Quit ""
	If Super = "" Quit 0
	
	If (Super [ "%DataType") || (Super [ "%Library.DataType") Quit 1
	
	For i = 1:1:$Length(Super, ",") {
		Set ClassName = $Piece(Super, ",", i)
		Set IsDataType = ..ClassIsDataType(ClassName)
		If IsDataType Quit
	}
	
	Quit IsDataType
]]></Implementation>
</Method>

<Method name="MRO">
<Description>
Member resolution order / inheritance order.
Returns a list of all superclasses of the given class. The order in
which they are returned is intended to be the order the compiler
uses to determine the origin of a member (if it has multiple origins).
Duplicates in the result (if e.g. a class inherits from %XML.Adaptor
via multiple superclasses) are removed.

By default, system classes are not returned in the results, but they
can be included by clearing ExcludeSystem. If errors occur they are
returned in output parameter Status.

See:
http://docs.intersystems.com/latest/csp/docbook/DocBook.UI.Page.cls?KEY=GOBJ_classes#GOBJ_model_inheritance_mult
</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>ClassNameOrObj:%Dictionary.ClassDefinition,ExcludeSystem:%Boolean=1,*Status:%Status</FormalSpec>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
	Set Result = ""
	
	If '$IsObject(ClassNameOrObj) {
		;Not an object, so a class name
		Set ClassName = $$$NormalizeClassname(ClassNameOrObj)
		Set ClassNameOrObj = ##class(%Dictionary.ClassDefinition).%OpenId(ClassName, , .Status)
		If 'Status Set Status = $$$BuildErr("Error opening definition for {}", Status, ClassName) Quit Result
	}
	
	;Skip system classes, including EnsLib.* etc., if so requested.
	If ExcludeSystem, ClassNameOrObj.System Quit ""
	
	;Always return "self' prefering %String over %Library.String
	Set Result = Result_$ListBuild($$$DenormalizeClassname(ClassNameOrObj.Name))
	
	;Get superclasses; if none, we're done.
	Set Super = ClassNameOrObj.Super
	If Super = "" Quit Result
	
#if ##safeexpression($System.Version.GetMajor()>=2010)
	;From v2010 onwards, inheritance is specified in the class definition
	If ClassNameOrObj.Inheritance = "left" {
		Set From = 1, To = $Length(Super, ","), Step = 1
	} Else {
		Set From = $Length(Super, ","), To = 1, Step = -1
	}
#else
	;Before v2010 inheritance is right to left always
	Set From = $Length(Super, ","), To = 1, Step = -1
#endif
	
	;Handle superclasses, in the order determined above, recursively
	For i = From:Step:To {
		Set Name = $Piece(Super, ",", i)
		If ExcludeSystem, $Extract(Name) = "%" Continue
		Set Result = Result_..MRO(Name, ExcludeSystem, .Status)
		If 'Status Quit
	}
	If 'Status Quit Result
	
	;De-duplicate
	Set WithDuplicates = Result, Result = ""
	For i = 1:1:$ListLength(WithDuplicates) {
		Set Name = $List(WithDuplicates, i)
		If $Data(Names(Name)) Continue
		Set Result = Result_$ListBuild(Name)
		Set Names(Name) = ""
	}
	
	Quit Result
]]></Implementation>
</Method>

<Method name="SqlName">
<Description>
Returns the SQL variant of a classname</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>ClassName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	;Try CompiledClass definition:
	&sql(SELECT SqlQualifiedNameQ INTO :SqlName FROM %Dictionary.CompiledClass WHERE Name = :ClassName)
	If SQLCODE = 0 Quit SqlName
	
	;Try class definition in case the table name is specified:
	&sql(SELECT SqlTableName INTO :SqlName FROM %Dictionary.ClassDefinition WHERE Name = :ClassName)
	If SqlName = "" Set SqlName = $Piece(ClassName, ".", $Length(ClassName, "."))
	
	;Attempt quoting of strange names the same way Caché does
	If SqlName '? 1A1.AN Set SqlName = """"_SqlName_""""
	
	If $Length(ClassName, ".") > 1 {
		Set Schema = $Piece(ClassName, ".", 1, $Length(ClassName, ".") - 1)
		Set Schema = $Replace(Schema, ".", "_")
	} Else {
		Set Schema = "User"
	}
	
	Quit Schema_"."_SqlName
]]></Implementation>
</Method>
</Class>
</Export>
