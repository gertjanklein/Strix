<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Class name="Strix.Lib.CSV">
<Description>
A class to parse CSV data formatted according to rfc4180.
Provides a resultset-like interface.</Description>
<IncludeCode>Strix</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>64661,63159.857904</TimeCreated>

<Property name="Input">
<Description>
The input data as a stream</Description>
<Type>%AbstractStream</Type>
</Property>

<Property name="Separator">
<Description>
The separator to use</Description>
<Type>%String</Type>
</Property>

<Property name="SkipCount">
<Description>
The number of initial (header) lines to skip on parsing</Description>
<Type>%Integer</Type>
</Property>

<UDLText name="T">
<Content><![CDATA[
// ----- Private data

]]></Content>
</UDLText>

<Property name="RecordNr">
<Description>
The number of the current record</Description>
<Type>%Integer</Type>
</Property>

<Property name="Data">
<Description>
The data, indexed by column number</Description>
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<UDLText name="T">
<Content><![CDATA[
// =====

]]></Content>
</UDLText>

<Method name="GetParser">
<ClassMethod>1</ClassMethod>
<FormalSpec>Input:%AbstractStream,Separator:%String=",",SkipCount:%Integer=0</FormalSpec>
<ReturnType>Strix.Lib.CSV</ReturnType>
<Implementation><![CDATA[
	Set Me = ..%New()
	Set Me.Input = Input
	Set Me.Separator = Separator
	Set Me.SkipCount = SkipCount
	Quit Me
]]></Implementation>
</Method>

<Method name="Next">
<Description>
Get the next record. Returns 0 if no more records available.</Description>
<FormalSpec>*Status:%Status</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	For  {
		Set ok = ..GetRecord(.Status)
		If 'ok Quit
		Set ..RecordNr = ..RecordNr + 1
		If ..RecordNr > ..SkipCount Quit
	}
	If 'ok Quit 0
	
	Quit 1
]]></Implementation>
</Method>

<Method name="Get">
<CodeMode>expression</CodeMode>
<FormalSpec>Column:%Integer,Default:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$Get(i%Data(Column), Default)
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =====

]]></Content>
</UDLText>

<Method name="GetRecord">
<FormalSpec>*Status:%Status</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set Status = $$$OK
	Kill ..Data Set ..Data = 0
	If ..Input.AtEnd Quit 0
	
	Set Line = ..Input.ReadLine( , .Status)
	If 'Status Quit 0
	If Line = "", ..Input.AtEnd Quit 0
	
	; If no quotes we can't span multiple lines
	
	If Line '[ """" {
		If Line = "" Quit 1
		Set ..Data = $Length(Line, ..Separator)
		For i = 1:1:..Data {
			Set ..Data(i) = $Piece(Line, ..Separator, i)
		}
		Quit 1
	}
	
	; Quotes present, more elaborate parsing needed.
	
	Set CellNr = 1
	Set Index = 1
	For  {
		; Check the first char of the record
		
		Set Char = $Extract(Line, Index)
		If Char = "" {
			; No more data, we're done
			
			Set ..Data = CellNr, ..Data(CellNr) = ""
			Quit
			
		} ElseIf Char = """" {
			; Quoted record, looking for a closing quote
			
			Set Index = Index + 1
			Set Cell = ""
			For  {
				Set Test = $Find(Line, """", Index)
				If Test = 0 {
					; No closing quote in the rest of this line; append another
					If ..Input.AtEnd {
						Set Msg = "Parsing error: end of data while looking for closing quote in record {}."
						Set Status = $$$BuildStatus(Msg, , ..RecordNr+1)
						Return 0
					}
					Set NextLine = ..Input.ReadLine( , .Status)
					If 'Status Return 0
					Set Line = Line_..Input.LineTerminator_NextLine
					Continue
				}
				Set NextChar = $Extract(Line, Test)
				If NextChar = "" {
					Set Cell = Cell_$Extract(Line, Index, Test-2)
					Set ..Data = CellNr, ..Data(CellNr) = Cell
					Return 1
				}
				If NextChar = """" {
					Set Cell = Cell_$Extract(Line, Index, Test-2)_""""
					Set Index = Test + 1
					Continue
				}
				If NextChar = ..Separator {
					Set Cell = Cell_$Extract(Line, Index, Test-2)
					Set ..Data = CellNr, ..Data(CellNr) = Cell, CellNr = CellNr + 1
					Set Index = Test + 1
					Quit
				}
				
				;Char after "closing" quote should be nothing, quote, or separator
				Set Msg = "Parsing error: lone quote in quoted field at record {}, character {}."
				Set Status = $$$BuildStatus(Msg, , ..RecordNr+1, Test-1)
				Return 0
			}
			
		} ElseIf Char = ..Separator {
			; At the start of the next record, this one is empty
			
			Set ..Data = CellNr, ..Data(CellNr) = "", CellNr = CellNr + 1
			Set Index = Index + 1
			
		} Else {
			; Normal data, look for next separator (ignoring quotes)
			
			Set Test = $Find(Line, ..Separator, Index+1)
			If Test = 0 {
				;No more separators
				Set ..Data = CellNr, ..Data(CellNr) = $Extract(Line, Index, *)
				Quit
			} Else {
				Set ..Data = CellNr, ..Data(CellNr) = $Extract(Line, Index, Test-2), CellNr = CellNr + 1
				Set Index = Test
			}
			
		}
	}
	
	Quit 1
]]></Implementation>
</Method>
</Class>
</Export>
